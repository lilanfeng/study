package HJ2023B200;

import java.util.concurrent.ConcurrentHashMap;

/**
 * 题目描述
 * 给定一个输入字符串，字符串只可能由英文字母（ ‘a’ ~ ‘z’、‘A’ ~ ‘Z’ ）和左右小括号（ ‘(’、‘)’ ）组成。
 * 当字符里存在小括号时，小括号是成对的，可以有一个或多个小括号对，小括号对不会嵌套，小括号对内可以包含1个或多个英文字母，也可以不包含英文字母。
 * 当小括号对内包含多个英文字母时，这些字母之间是相互等效的关系，而且等效关系可以在不同的小括号对之间传递，即当存在 ‘a’ 和 ‘b’ 等效和存在 ‘b’ 和 ‘c’ 等效时，‘a’ 和 ‘c’
 * 也等效，另外，同一个英文字母的大写字母和小写字母也相互等效（即使它们分布在不同的括号对里）
 * 需要对这个输入字符串做简化，输出一个新的字符串，输出字符串里只需保留输入字符串里的没有被小括号对包含的字符（按照输入字符串里的字符顺序），并将每个字符替换为在小括号对里包含的且字典序最小的等效字符。
 * 如果简化后的字符串为空，请输出为"0"。
 *
 * 示例 :
 * 输入字符串为"never(dont)give(run)up(f)()"，初始等效字符集合为(‘d’, ‘o’, ‘n’, ‘t’)、(‘r’, ‘u’, ‘n’)，由于等效关系可以传递，因此最终等效字符集合为(‘d’, ‘o’,
 * ‘n’, ‘t’, ‘r’, ‘u’)，将输入字符串里的剩余部分按字典序最小的等效字符替换后得到"devedgivedp’
 *
 * 输入描述
 * input_string
 * 输入为1行，代表输入字符串
 *
 * 输出描述
 * output_string
 * 输出为1行，代表输出字符串
 *
 * 备注
 * 输入字符串的长度在1~100000之间
 *
 * 用例
 * 输入	()abd
 * 输出	abd
 * 说明	输入字符串里没有被小括号包含的子字符串为"abd"，其中每个字符没有等效字符，输出为"abd"
 * 输入	(abd)demand(fb)()for
 * 输出	aemanaaor
 * 说明	等效字符集为('a', 'b', 'd', 'f')，输入字符串里没有被小括号包含的子字符串集合为'demandfor"，将其中字符替换为字典序最小的等效字符后输出为："aemanaaor"
 * 输入	()happy(xyz)new(wxy)year(t)
 * 输出	happwnewwear
 * 说明	等效字符集为(‘x’, 'y', 'z', 'w')，输入字符串里没有被小括号包含的子字符串集合为"happynewyear"，将其中字符替换为字典序最小的等效字符后输出为："happwnewwear"
 * 输入	()abcdefgAC(a)(Ab)(C)
 * 输出	AAcdefgAC
 * 说明	等效字符集为('a', 'A', 'b')，输入字符里没有被小括号包含的子字符串集合为"abcdefgAC"，将其中字符替换为字典序最小的等效字符后输出为："AAcdefgAC"
 * 解题思路
 * 上面的代码实现了一个字符串处理的功能。下面是代码的详细解题思路：
 * 首先，创建一个Scanner对象用于读取用户输入的字符串。
 * 读取用户输入的字符串。
 * 创建一个StringBuilder对象用于存储最终的输出结果。
 * 创建一个LinkedList对象用于存储等价集合。
 * 创建一个标志变量isInsideParentheses，用于判断当前是否在括号内部，默认为false。
 * 遍历输入字符串的每个字符：
 * 如果当前字符是左括号’('，则表示进入了括号内部，将isInsideParentheses设置为true，并创建一个新的等价集合，并将其添加到LinkedList中。
 * 如果当前字符是右括号’)'，则表示离开了括号内部，将isInsideParentheses设置为false，并检查最后一个等价集合是否为空集合，如果是空集合，则将其从LinkedList中移除。
 * 如果当前字符既不是左括号也不是右括号：
 * 如果当前不在括号内部，则直接将字符添加到输出结果中。
 * 如果当前在括号内部，则将字符添加到最后一个等价集合中。
 * 创建一个标志变量merged，用于判断是否进行了合并操作，默认为true。
 *
 * 循环执行合并操作，直到没有可以合并的等价集合为止：
 *
 * 遍历等价集合LinkedList中的每个等价集合：
 * 遍历等价集合LinkedList中的每个等价集合（从当前等价集合的下一个开始）：
 * 创建一个标志变量canCombine，用于判断两个等价集合是否可以合并，默认为false。
 * 遍历字母’a’到’z’，判断两个等价集合是否可以合并：
 * 如果两个等价集合中都包含当前字母或者对应的大写字母，则可以合并，将canCombine设置为true，并跳出循环。
 * 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从LinkedList中移除第二个等价集合，将merged设置为true，并跳出循环。
 * 将输出结果转换为字符数组。
 *
 * 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符。
 *
 * 将字符数组转换为字符串。
 *
 * 如果结果字符串为空，则将最终结果设置为"0"，否则将最终结果设置为结果字符串。
 * ————————————————
 * 版权声明：本文为CSDN博主「算法大师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
 * 原文链接：https://blog.csdn.net/banxia_frontend/article/details/131159946
 */
public class _009_字符串化繁为简 {

}
